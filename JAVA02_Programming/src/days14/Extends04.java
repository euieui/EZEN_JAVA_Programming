package days14;
// 일반 객체의 생성과정
// 1. 멤버 필드 메모리 로딩
// 2. 생성자 호출

// 상속관계에서의 객체 생성과정
// 1. 멤버 필드의 메모리 로딩 - 부모/자식 클래스으 ㅣ모든 멤버필드가 메모리 로딩
// 2. 생성자 호출(먼저 자식 클래스의 생성자 호출)
// 3. 자식 클래스 생성자의 첫 번째 실행 코드인 super()에 의해 부모클래스의
//     생성자 호출. super() 라는 명령은 따로 쓰지 않아도 이미 존재하며 부모 클래스가
//     있다면 자동 호출되는 명령.
// 4. 자식 클래스의 생성자의 나머지 코드들 실행
// - 부모 클래스의 private 멤버와 같은 경우 자식클래스에서 초기화를 할 수 없기
//   때문에 부모클래스의 생성자를 통해 초기화를 실행
class SuperB{
	int superNum;
	public SuperB() {
		System.out.println("부모클래스의 생성자 실행");
	}
}

class SubB extends SuperB{ // SuperB 클래스 상속
	int subNum;
	// 생성자를 별도로 거내서 정의 하지 않았다면....
	// 보이지않는 곳에 디폴트 생성자가 존재할 것이며, 그의 첫번째 명령은
	// 아래와 같이 Super(); 가 되어 있습니다.
	// SubB(){ super();}
	
	// 디폴트 생성자를 별도로 꺼내서 정의 한 경우.....
	SubB(){ /// --- 내가 스스로 super(); 를 써야한다면 맨위에 쓰자~
		super(); // 생략 가능.
		// 자식 클래스에서 부모클래스 생성자 호출은 super(); 라고 명령하며,
		// 반드시 첫번째 실행코드로 씁니다
		// 다만 부모 클래스의 생성자가 오버로딩 되거나 하지 않았다면 쓰지 않아도
		// Super(); 명령은 실행됩니다.
		// 부모클래스 생성자가 디폴트생성자만 있을시 super(); 명령 생략 - 자동 호출
		System.out.println("자식클래스의 생성자 실행");
	}
	
	// 매개변수가 있는 생성자가 오버로딩 된 경우....    this() 로 형제 생성자를 호출한 경우
	public SubB(int subNum) {// 오버로딩 된 자식 클래스 생성자
		// 자식 클래스의 오버로딩된 생성자의 첫번째 실행코드는 super() 또는
		// this()를 코딩하는데 그 둘울 같이 실행할 수는 없습니다.
		// 현재 클래스의 매개변수가 없는 생성자를 this()를 호출하고 그안에서   // --- 아 이뜻이구나 super랑 this랑 동시에 안되니까 위에다가 super후 this로 불러오는거지
		// super()가 실행되도록합니다.
		this(); // -- 형제 생성자를 호출하고 너가 부모 생성자를 호출해줘~ 이렇게 되는거지! 맞네
		System.out.println("자식클래스의 오버로딩된 생성자 실행(this(O)");
		// 부모나 형제 생성자에 매개변수가 있는 경우 반드시
		// 호출하려는 super() 또는 this()의 매개변수에 맞춰 전달인수를 전달합니다.
	}
	// 매개변수가 있는 생성자가 오버로딩 된 경우...
	// this() 로 형제 생성자를 호출하지 않은 경우
	public SubB(int subNum, int num) {
		// -- super();  슈퍼 안써도 슈퍼가 발동되는듯?
		System.out.println("자식클래스의 오버로딩된 생성자 실행(this(x)");
	}

}

public class Extends04 {

	public static void main(String[] args) {
		 //--> 부모 생성자를 바로 실행 자동으로 실행주는구나 
		// --- 의문이 생기는 구나 생성자를 만들어 놓으면? 부모도 바로 만들어지나? 그러네 그래도 부모 만들어지네
		// --- 안만들어 질 수 도 있을가?
		// --- 의문 부모 생성자가 오버로딩 되어있으면?
		
		SubB b = new SubB();
		System.out.println();
		SubB c = new SubB(20);
		System.out.println();
		SubB d = new SubB(20,40);
	}

}
